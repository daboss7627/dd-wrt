#!/bin/sh
nv=/usr/sbin/nvram
/bin/mkdir -p /tmp/oet/pid
cd /tmp/oet/pid
rmmod eoip >/dev/null 2>&1
tunnels=$($nv get oet_tunnels)
# set failstate, 0 is default meaning tunnel can start (at (re)boot failstate of all tunnels is set to 0, sysinit.c:3386), 1 is failed, set to 2 if this is the one to start
if [[ $tunnels -gt 0 ]]; then
	fset=0
	for i in $(seq 1 $tunnels); do
		[[ -z $($nv get oet${i}_failgrp) ]] && $nv set oet${i}_failgrp=0 #add missing default delete in future version
		if [[ $($nv get oet${i}_en) -eq 1 && $($nv get oet${i}_failgrp) -eq 1 && $($nv get oet${i}_failstate) -eq 2  ]]; then
			fset=$((fset+1))
			logger -p user.info "WireGuard tunnel oet${i} is the fail over group start tunnel"
		fi
	done
	for i in $(seq 1 $tunnels); do
		if [[ $($nv get oet${i}_en) -ne 1 ]]; then #non enabled tunnels reset
			$nv set oet${i}_failstate=0
		else #enabled tunnels
			if [[ $($nv get oet${i}_failgrp) -eq 1 ]]; then
				#search for first tunnel with failgroup enabled which is not failed and set to 2
				if [[ $($nv get oet${i}_failstate) -eq 0 ]]; then #non failed tunnels
					if [[ $fset -eq 0 ]]; then
						fset=$((fset+1))
						#set this tunnel to start the fail over group
						logger -p user.info "WireGuard tunnel oet${i} is the fail over group start tunnel"
						$nv set oet${i}_failstate=2
					else  #number of failgroup running or standby
						fset=$((fset+1))
						#$nv set oet${i}_failstate=0
					fi
				fi
			else #enabled tunnels not part of fail group reset
				$nv set oet${i}_failstate=0
			fi
		fi
	done
	logger -p user.info "WireGuard number of non failed tunnels in fail set: $fset"
fi
#reset dns
if [[ -e /tmp/resolv.dnsmasq_oet ]]; then
	logger -p user.info "WireGuard DNS reset"
	cp -f /tmp/resolv.dnsmasq_oet /tmp/resolv.dnsmasq
	rm -f /tmp/resolv.dnsmasq_oet
fi
$nv unset wg_get_dns
for i in $(seq 1 $tunnels); do
	if [[ -e "${i}.pid" ]]; then
		#remove route to endpoint start before taking wg interface down
		peers=$(($($nv get oet${i}_peers) - 1))
		for p in $(seq 0 $peers); do
			endp="$($nv get oet${i}_rem${p})"
			if [[ ! -z $endp && $endp != 0.0.0.0 ]] >/dev/null 2>&1; then
				#if endpoint is IPv6 do nothing yet otherwise parse endpoint from wg interface
				if [ "$endp" != "${endp#*:[0-9a-fA-F]}" ]; then
					logger -p user.warning "WireGuard: endpoint: $endp is IPv6, not yet implemented"
					endpip=""
				else
					pk=$($nv get oet${i}_peerkey${p})
					#endpip=$(/usr/bin/wg | sed "/oet${i}/,/interface/!d;/interface/d" | sed "/${pk//\//\\\/}/,/peer/!d;/peer/d" | sed -n "/endpoint: /{s/.*endpoint: //;s/:.*//;p}" 2>/dev/null) >/dev/null 2>&1
					endpip=$(/usr/bin/wg showconf oet${i} | sed "/${pk//\//\\\/}/,/Peer/!d;/Peer/d" | awk -F"Endpoint = " '/Endpoint = /{print $2}' 2>/dev/null) >/dev/null 2>&1
					endpip="${endpip%:*}"
				fi
				#IPv6  if [[ ! -z $endpip ]] && [[ "$endpip" != "${endpip#*[0-9].*[0-9].*[0-9].*[0-9]}" || "$endpip" != "${endpip#*:[0-9a-fA-F]}" ]] >/dev/null 2>&1;then 
				if [[ ! -z $endpip && "$endpip" != "${endpip#*[0-9].[0-9]}" ]] >/dev/null 2>&1; then
					ip route del $endpip >/dev/null 2>&1
					logger -p user.info "WireGuard: Deleted endpoint route to $endpip from $endp"
				else
					logger -p user.warning "WireGuard: Could not delete endpoint route from oet${i} peer${p} to $endpip from $endp"
				fi
			fi
		done
		{
		emf del iface $(getbridge oet${i}) oet${i}
		brctl delif $(getbridge oet${i}) oet${i}
		ip tunnel del oet${i}
		ip link del oet${i}
		rm -f ${i}.pid
		} >/dev/null 2>&1
		TID=$((20+$i))
		while ip rule delete from 0/0 to 0/0 table $TID >/dev/null 2>&1; do true; done
		ip route flush table $TID
		logger -p user.info "Flush delete PBR interface oet${i}, table : $TID"
		ps | grep "[w]ireguard-fwatchdog" | awk '{print $1}' | xargs kill -9 >/dev/null 2>&1 #use [w] to exclude the ps line
		[[ ! -z "$($nv get oet${i}_rtdownscript | sed '/^[[:blank:]]*#/d')" ]] && { sh $($nv get oet${i}_rtdownscript) & }
		# remove destination routes
		WGDPBRIP="/tmp/wgdpbrip_oet${i}"
		if [[ -f "$WGDPBRIP" ]]; then
			(while read dpbrip; do ip route del $dpbrip >/dev/null 2>&1; done < $WGDPBRIP)
			rm $WGDPBRIP >/dev/null 2>&1
		fi
		ip route flush cache
	fi
done
for i in $(seq 1 $tunnels); do
	if [[ $($nv get oet${i}_en) -eq 1 ]]; then
		if [[ $($nv get oet${i}_proto) -eq 2 ]] && [[ $($nv get oet${i}_failgrp) -ne 1 || $($nv get oet${i}_failstate) -eq 2 ]]; then
			{
			mkdir -p /tmp/wireguard
			insmod ipv6
			insmod udp_tunnel
			insmod ip6_udp_tunnel
			insmod ip_tunnel
			insmod wireguard
			} >/dev/null 2>&1
			logger -p user.info "Enable WireGuard interface oet${i} on port $($nv get oet${i}_port)"
			if [ -z "$($nv get oet${i}_mtu)" ]; then
				overhead=60
				if [ "$($nv get ipv6_enable)" == "1" ]; then
					overhead=80
				fi
				if [ "$($nv get wan_proto)" != "disabled" ]; then
					$nv set oet${i}_mtu=$(($($nv get wan_mtu) - $overhead))
				else
					$nv set oet${i}_mtu=$((1500 - $overhead))
				fi
			fi
			ip link add oet${i} type wireguard
			wg set oet${i} listen-port $($nv get oet${i}_port)
			$nv get oet${i}_private > /tmp/wireguard/oet${i}_private
			wg set oet${i} private-key /tmp/wireguard/oet${i}_private
			$nv set oet${i}_public="$($nv get oet${i}_private|wg pubkey)"
			if [[ ! -z "$($nv get oet${i}_fwmark)" ]]; then
				wg set oet${i} fwmark $($nv get oet${i}_fwmark)
			fi
			peers=$(($($nv get oet${i}_peers) - 1))
			$nv set oet${i}_bridged=0
			$nv set oet${i}_nat=0
			for p in $(seq 0 $peers); do
				PSKARG1=
				PSKARG2=
				ENDPOINTARG1=
				ENDPOINTARG2=
				if [ $($nv get oet${i}_usepsk${p}) -eq 1 ]; then
					$nv get oet${i}_psk${p} > /tmp/wireguard/oet${i}_psk${p}
					PSKARG1="preshared-key" 
					PSKARG2="/tmp/wireguard/oet${i}_psk${p}"
				fi
				if [ $($nv get oet${i}_endpoint${p}) -eq 1 ]; then
					logger -p user.info "Establishing WireGuard tunnel with peer endpoint $($nv get oet${i}_rem${p}):$($nv get oet${i}_peerport${p})"
					ENDPOINTARG1="endpoint"
					ENDPOINTARG2="$($nv get oet${i}_rem${p}):$($nv get oet${i}_peerport${p})"
					GATEWAY="$($nv get wan_gateway)"
					[[ $($nv get wan_proto) = "disabled" ]] && { GATEWAY="$($nv get lan_gateway)"; logger -p user.info "WireGuard no wan_gateway detected, assuming WAP"; }
					#Note the resolve of the host (DNS) might be problematic, WG should wait and retry, consider moving this to eop-tunnel-raip.sh
					route add -host $($nv get oet${i}_rem${p}) gw $GATEWAY dev $(get_wanface) >/dev/null 2>&1
					logger -p user.info "WireGuard setting route for oet${i} to endpoint $($nv get oet${i}_rem${p}):$($nv get oet${i}_peerport${p}) via $GATEWAY dev $(get_wanface)"
				fi
				wg set oet${i} peer $($nv get oet${i}_peerkey${p}) persistent-keepalive $($nv get oet${i}_ka${p}) $PSKARG1 $PSKARG2 allowed-ips "$($nv get oet${i}_aip${p})" $ENDPOINTARG1 $ENDPOINTARG2 &
			done
			ifconfig oet${i} promisc up >/dev/null 2>&1
			ip link set mtu $($nv get oet${i}_mtu) up dev oet${i} >/dev/null 2>&1
			echo enable > ${i}.pid
			# alternative input with ipaddrmask
			if [[ ! -z "$($nv get oet${i}_ipaddrmask)" ]]
			then
				for ipaddrmask in $($nv get oet${i}_ipaddrmask | sed "s/,/ /g") ; do
					# set ip address and netmask for backwards compatibility only for IPv4
					case $ipaddrmask in
					  *.*) #IPv4
						IPADDR=${ipaddrmask%%/*}
						mask="${ipaddrmask#*/}"
						# error handling if netmask is not specified
						if [[ $mask -lt 33 ]] ;then
							mask="${ipaddrmask#*/}"
						else
							logger -p user.info "ERROR: WireGuard no valid tunnel address for oet${i}: $ipaddrmask, please correct, using /24"
							mask=24
						fi
						ip addr add $IPADDR/$mask dev oet${i} >/dev/null 2>&1
						logger -p user.info "WireGuard $IPADDR/$mask added to oet${i}"
						set -- $(( 5 - ($mask / 8) )) 255 255 255 255 $(( (255 << (8 - ($mask % 8))) & 255 )) 0 0 0
						[ $1 -gt 1 ] && shift $1 || shift
						NETMASK=${1-0}.${2-0}.${3-0}.${4-0}
						$nv set oet${i}_ipaddr=$IPADDR
						$nv set oet${i}_netmask=$NETMASK
						;;
					  *:*) #IPv6
						ip addr add $ipaddrmask dev oet${i} >/dev/null 2>&1
						logger -p user.info "WireGuard $ipaddrmask added to oet${i}"
						;;
					  *)
						logger -p user.info "ERROR: WireGuard no valid IPv4 or IPV6 tunnel address for oet${i}: $ipaddrmask, please correct"
						;;
					esac
				done
			else
				logger -p user.info "ERROR: WireGuard no valid IPv4 or IPV6 tunnel address for oet${i}: $ipaddrmask, please correct, trying the old way"
				ip addr add $($nv get oet${i}_ipaddr)/$(getmask $($nv get oet${i}_netmask)) dev oet${i} >/dev/null 2>&1
			fi
		fi
		if [ $($nv get oet${i}_proto) -eq 1 ]; then
			insmod gre
			insmod eoip
			logger -p user.info "Enable Mikrotik Tunnel interface oet${i} on address $($nv get oet${i}_local) with peer $($nv get oet${i}_rem)"
			eoip add tunnel-id $($nv get oet${i}_id) name oet${i} remote $($nv get oet${i}_rem) local $($nv get oet${i}_local)
			if [ $($nv get oet${i}_bridged) -eq 1 ]; then
				ifconfig oet${i} up >/dev/null 2>&1
				ifconfig oet${i} promisc >/dev/null 2>&1
				brctl addif $(getbridge oet${i}) oet${i} >/dev/null 2>&1
				setportprio $(getbridge oet${i}) oet${i}
				emf add iface $(getbridge oet${i}) oet${i} >/dev/null 2>&1
			else
				ifconfig oet${i} promisc up >/dev/null 2>&1
				ip addr add $($nv get oet${i}_ipaddr)/$(getmask $($nv get oet${i}_netmask)) dev oet${i} >/dev/null 2>&1
			fi
			echo enable > ${i}.pid
		fi
		if [ $($nv get oet${i}_proto) -eq 0 ]; then
			insmod etherip
			if [ $($nv get oet${i}_local) == "0.0.0.0" ]; then
				logger -p user.info "Enable RFC 3378 EtherIP Tunnel interface oet${i} with peer $($nv get oet${i}_rem)"
				ip tunnel add oet${i} mode etherip remote $($nv get oet${i}_rem) local any
			else
				logger -p user.info "Enable RFC 3378 EtherIP Tunnel interface oet${i} on address $($nv get oet${i}_local) with peer $($nv get oet${i}_rem)"
				ip tunnel add oet${i} mode etherip remote $($nv get oet${i}_rem) local $($nv get oet${i}_local)
			fi
			if [ $($nv get oet${i}_bridged) -eq 1 ]; then
				ip link set dev oet${i} up
				ifconfig oet${i} up >/dev/null 2>&1
				ifconfig oet${i} promisc >/dev/null 2>&1
				brctl addif $(getbridge oet${i}) oet${i} >/dev/null 2>&1
				setportprio $(getbridge oet${i}) oet${i}
				emf add iface $(getbridge oet${i}) oet${i} >/dev/null 2>&1
			else
				ip link set dev oet${i} up
				ifconfig oet${i} promisc >/dev/null 2>&1
				ip addr add $($nv get oet${i}_ipaddr)/$(getmask $($nv get oet${i}_netmask)) dev oet${i} >/dev/null 2>&1
    			fi
			echo enable > ${i}.pid
		fi
	fi
done
service set_routes start
# start route setting only if active tunnels
for i in $(seq 1 $tunnels); do
	if [[ $($nv get oet${i}_en) -eq 1 ]]; then
		/usr/bin/eop-tunnel-raip.sh $fset &
		break
	fi
done

